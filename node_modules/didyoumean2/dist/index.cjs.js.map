{"version":3,"file":"index.cjs.js","sources":["../src/enums/ReturnTypeEnums.ts","../src/enums/ThresholdTypeEnums.ts","../src/errors.ts","../src/lib/fillDefaultOptions.ts","../src/lib/getSimilarity.ts","../src/lib/normalizeString.ts","../src/lib/matchItemProcessor.ts","../src/lib/resultProcessor.ts","../src/index.ts"],"sourcesContent":["export enum ReturnTypeEnums {\n  ALL_CLOSEST_MATCHES = 'all-closest-matches',\n  ALL_MATCHES = 'all-matches',\n  ALL_SORTED_MATCHES = 'all-sorted-matches',\n  FIRST_CLOSEST_MATCH = 'first-closest-match',\n  FIRST_MATCH = 'first-match'\n}\n","export enum ThresholdTypeEnums {\n  EDIT_DISTANCE = 'edit-distance',\n  SIMILARITY = 'similarity'\n}\n","export const unknownReturnTypeError = new Error('unknown returnType')\nexport const unknownThresholdTypeError = new Error('unknown thresholdType')\n","import {ReturnTypeEnums} from '../enums/ReturnTypeEnums'\nimport {ThresholdTypeEnums} from '../enums/ThresholdTypeEnums'\nimport {unknownThresholdTypeError} from '../errors'\nimport {InputOptions, Options} from '../types'\n\nconst fillDefaultOptions = (options?: InputOptions): Options => {\n  const optionsWithDefaultValues = {\n    caseSensitive: false,\n    deburr: false,\n    matchPath: [],\n    returnType: ReturnTypeEnums.FIRST_CLOSEST_MATCH,\n    thresholdType: ThresholdTypeEnums.SIMILARITY,\n    trimSpaces: true,\n    ...options\n  }\n\n  switch (optionsWithDefaultValues.thresholdType) {\n    case ThresholdTypeEnums.EDIT_DISTANCE:\n      return {\n        threshold: 20,\n        ...optionsWithDefaultValues\n      }\n\n    case ThresholdTypeEnums.SIMILARITY:\n      return {\n        threshold: 0.4,\n        ...optionsWithDefaultValues\n      }\n\n    /* istanbul ignore next */\n    default:\n      throw unknownThresholdTypeError\n  }\n}\nexport default fillDefaultOptions\n","import leven from 'leven'\n\n/**\n * Using edit distance between `a` and `b` to calculate similarity\n * @param {string} a - `input`\n * @param {string} b - String from `matchList`\n * @return {number} similarity between `a` and `b`\n */\nconst getSimilarity = (a: string, b: string): number => {\n  if (!a || !b) return 0\n  if (a === b) return 1\n\n  const editDistance = leven(a, b)\n  const longestLength = Math.max(a.length, b.length)\n\n  return (longestLength - editDistance) / longestLength\n}\n\nexport default getSimilarity\n","import deburr from 'lodash.deburr'\n\nimport {Options} from '../types'\n\n/**\n * Normalize a string\n * @param {string} str - any string\n * @param {Object} options - options that allows you to modify the behavior\n * @returns {string} - normalized string\n */\nconst normalizeString = (str: string, options: Options): string => {\n  let s = str\n\n  if (options.trimSpaces) {\n    s = s.trim().replace(/\\s+/g, ' ')\n  }\n\n  if (options.deburr) {\n    s = deburr(s)\n  }\n\n  if (!options.caseSensitive) {\n    s = s.toLowerCase()\n  }\n\n  return s\n}\n\nexport default normalizeString\n","import pathOr from 'ramda/src/pathOr'\n\nimport {Options} from '../types'\nimport normalizeString from './normalizeString'\n\n/**\n * Process matchItem according to options\n * @param {Object|string} matchItem - Item for matching with `input`\n * @param {Object} options - options that allows you to modify the behavior\n * @returns {string} - processed matchItem\n */\nconst matchItemProcessor = (matchItem: object | string, options: Options): string => {\n  const {matchPath} = options\n\n  const matchItemStr =\n    Array.isArray(matchPath) && matchPath.length ? pathOr('', matchPath, matchItem) : matchItem\n  if (typeof matchItemStr !== 'string') {\n    return ''\n  }\n\n  return normalizeString(matchItemStr, options)\n}\n\nexport default matchItemProcessor\n","import {ReturnTypeEnums} from '../enums/ReturnTypeEnums'\n\n/**\n * Generate result\n * @param {Object[]|string[]} matchList - List for matching with `input`\n * @param {number[]} matchedIndexes - indexes of matchList that need to be returned as result\n * @param {string} returnType\n * @returns {Array|null|Object|string} - matched result(s), return object if `match` is `{Object[]}`\n */\nconst resultProcessor = <T>(\n  matchList: ReadonlyArray<T>,\n  matchedIndexes: ReadonlyArray<number>,\n  returnType: ReturnTypeEnums\n): Array<T> | T | null => {\n  switch (returnType) {\n    case ReturnTypeEnums.ALL_CLOSEST_MATCHES:\n    case ReturnTypeEnums.ALL_MATCHES:\n    case ReturnTypeEnums.ALL_SORTED_MATCHES:\n      return matchedIndexes.map((matchedIndex) => matchList[matchedIndex])\n\n    case ReturnTypeEnums.FIRST_CLOSEST_MATCH:\n    case ReturnTypeEnums.FIRST_MATCH:\n      if (!matchedIndexes.length) return null\n      return matchList[matchedIndexes[0]]\n\n    /* istanbul ignore next */ default:\n      return null\n  }\n}\n\nexport default resultProcessor\n","import leven from 'leven'\n\nimport {ReturnTypeEnums} from './enums/ReturnTypeEnums'\nimport {ThresholdTypeEnums} from './enums/ThresholdTypeEnums'\nimport {unknownReturnTypeError, unknownThresholdTypeError} from './errors'\nimport fillDefaultOptions from './lib/fillDefaultOptions'\nimport getSimilarity from './lib/getSimilarity'\nimport matchItemProcessor from './lib/matchItemProcessor'\nimport normalizeString from './lib/normalizeString'\nimport resultProcessor from './lib/resultProcessor'\nimport {InputOptions} from './types'\n\n/**\n * Main function for didyoumean2\n * @param {string} input - string that you are not sure and want to match with `matchList`\n * @param {Object[]|string[]} matchList - List for matching with `input`\n * @param {null|Object|undefined} options - options that allows you to modify the behavior\n * @returns {Array|null|Object|string} - matched result(s), return object if `match` is `{Object[]}`\n */\nconst didYouMean = <T extends object | string>(\n  input: string,\n  matchList: ReadonlyArray<T>,\n  options?: InputOptions\n): Array<T> | T | null => {\n  /*+++++++++++++++++++\n   + Initiate options +\n   +++++++++++++++++++*/\n\n  const optionsWithDefaults = fillDefaultOptions(options)\n\n  const {returnType, threshold, thresholdType} = optionsWithDefaults\n\n  /*++++++++++++++++++++\n   + Deal with options +\n   ++++++++++++++++++++*/\n\n  const normalizedInput = normalizeString(input, optionsWithDefaults)\n\n  let checkIfMatched // Validate if score is matched\n  let scoreProcessor // Get score\n  switch (thresholdType) {\n    case ThresholdTypeEnums.EDIT_DISTANCE:\n      checkIfMatched = (score: number) => score <= threshold\n      scoreProcessor = (matchItem: T) =>\n        leven(normalizedInput, matchItemProcessor(matchItem, optionsWithDefaults))\n      break\n\n    case ThresholdTypeEnums.SIMILARITY:\n      checkIfMatched = (score: number) => score >= threshold\n      scoreProcessor = (matchItem: T) =>\n        getSimilarity(normalizedInput, matchItemProcessor(matchItem, optionsWithDefaults))\n      break\n\n    /* istanbul ignore next */ default:\n      throw unknownThresholdTypeError\n  }\n\n  /*+++++++++++\n   + Matching +\n   +++++++++++*/\n\n  const matchedIndexes = []\n  const matchListLen = matchList.length\n\n  switch (returnType) {\n    case ReturnTypeEnums.ALL_CLOSEST_MATCHES:\n    case ReturnTypeEnums.FIRST_CLOSEST_MATCH: {\n      const scores = []\n\n      let marginValue\n      switch (thresholdType) {\n        case ThresholdTypeEnums.EDIT_DISTANCE:\n          // Process score and save the smallest score\n          marginValue = Infinity\n          for (let i = 0; i < matchListLen; i += 1) {\n            const score = scoreProcessor(matchList[i])\n\n            // eslint-disable-next-line max-depth\n            if (marginValue > score) marginValue = score\n\n            scores.push(score)\n          }\n          break\n\n        case ThresholdTypeEnums.SIMILARITY:\n          // Process score and save the largest score\n          marginValue = 0\n          for (let i = 0; i < matchListLen; i += 1) {\n            const score = scoreProcessor(matchList[i])\n\n            // eslint-disable-next-line max-depth\n            if (marginValue < score) marginValue = score\n\n            scores.push(score)\n          }\n          break\n\n        /* istanbul ignore next */ default:\n          throw unknownThresholdTypeError\n      }\n\n      const scoresLen = scores.length\n      for (let i = 0; i < scoresLen; i += 1) {\n        const score = scores[i]\n\n        if (checkIfMatched(score) && score === marginValue) {\n          matchedIndexes.push(i)\n        }\n      }\n\n      break\n    }\n\n    case ReturnTypeEnums.ALL_MATCHES:\n      for (let i = 0; i < matchListLen; i += 1) {\n        const score = scoreProcessor(matchList[i])\n\n        // save all indexes of matched scores\n        if (checkIfMatched(score)) {\n          matchedIndexes.push(i)\n        }\n      }\n\n      break\n\n    case ReturnTypeEnums.ALL_SORTED_MATCHES: {\n      const unsortedResults = []\n      for (let i = 0; i < matchListLen; i += 1) {\n        const score = scoreProcessor(matchList[i])\n\n        // save all indexes of matched scores\n        if (checkIfMatched(score)) {\n          unsortedResults.push({\n            score,\n            index: i\n          })\n        }\n      }\n\n      switch (thresholdType) {\n        case ThresholdTypeEnums.EDIT_DISTANCE:\n          unsortedResults.sort((a, b) => a.score - b.score)\n          break\n\n        case ThresholdTypeEnums.SIMILARITY:\n          unsortedResults.sort((a, b) => b.score - a.score)\n          break\n\n        /* istanbul ignore next */ default:\n          throw unknownThresholdTypeError\n      }\n\n      for (const unsortedResult of unsortedResults) {\n        matchedIndexes.push(unsortedResult.index)\n      }\n\n      break\n    }\n\n    case ReturnTypeEnums.FIRST_MATCH:\n      for (let i = 0; i < matchListLen; i += 1) {\n        const score = scoreProcessor(matchList[i])\n\n        // Return once matched, performance is main target in this returnType\n        if (checkIfMatched(score)) {\n          matchedIndexes.push(i)\n          break\n        }\n      }\n\n      break\n\n    /* istanbul ignore next */ default:\n      throw unknownReturnTypeError\n  }\n\n  /*+++++++++++++++++++++++\n   + Process return value +\n   +++++++++++++++++++++++*/\n\n  return resultProcessor(matchList, matchedIndexes, returnType)\n}\n\nexport default didYouMean\nexport {ReturnTypeEnums, ThresholdTypeEnums}\n"],"names":["ReturnTypeEnums","ThresholdTypeEnums","unknownReturnTypeError","Error","unknownThresholdTypeError","fillDefaultOptions","options","optionsWithDefaultValues","caseSensitive","deburr","matchPath","returnType","FIRST_CLOSEST_MATCH","thresholdType","SIMILARITY","trimSpaces","EDIT_DISTANCE","threshold","getSimilarity","a","b","editDistance","leven","longestLength","Math","max","length","normalizeString","str","s","trim","replace","toLowerCase","matchItemProcessor","matchItem","matchItemStr","Array","isArray","pathOr","resultProcessor","matchList","matchedIndexes","ALL_CLOSEST_MATCHES","ALL_MATCHES","ALL_SORTED_MATCHES","map","matchedIndex","FIRST_MATCH","didYouMean","input","checkIfMatched","scoreProcessor","optionsWithDefaults","normalizedInput","score","matchListLen","marginValue","scores","Infinity","i","push","scoresLen","unsortedResults","index","sort","unsortedResult"],"mappings":"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"}